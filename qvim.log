Line:0 Str:#include<iostream>
Line:1 Str:#include<fstream>
Line:2 Str:#include<vector>
Line:3 Str:#include<utility>
Line:4 Str:#ifdef _WIN32
Line:5 Str:#include <conio.h>
Line:6 Str:#else
Line:7 Str:#include <termios.h>
Line:8 Str:#include <sys/ioctl.h>
Line:9 Str:#include <unistd.h>
Line:10 Str:#include <sys/select.h>
Line:11 Str:#include <sys/time.h>
Line:12 Str:#endif
Line:13 Str:#include"./include/buffer.h"
Line:14 Str:#include"./include/edit.h"
Line:15 Str:#include"./include/cursor.h"
Line:16 Str:#include"./include/tui.h"
Line:17 Str:using std::cout;
Line:18 Str:using std::cin;
Line:19 Str:using std::flush;
Line:20 Str:using std::endl;
Line:21 Str:using std::vector;
Line:22 Str:enum KeyCode {
Line:23 Str:    KEY_ESC = 27,
Line:24 Str:    KEY_ENTER = 10,
Line:25 Str:    KEY_BACKSPACE = 127,
Line:26 Str:    KEY_UP = 256,
Line:27 Str:    KEY_DOWN = 257,
Line:28 Str:    KEY_LEFT = 258,
Line:29 Str:    KEY_RIGHT = 259
Line:30 Str:};
Line:31 Str:
Line:32 Str:// 最简单的 getch 函数
Line:33 Str:char getch_simple() {
Line:34 Str:#ifdef _WIN32
Line:35 Str:    return _getch();
Line:36 Str:#else
Line:37 Str:    char ch;
Line:38 Str:    struct termios oldt, newt;
Line:39 Str:    
Line:40 Str:    tcgetattr(STDIN_FILENO, &oldt);
Line:41 Str:    newt = oldt;
Line:42 Str:    newt.c_lflag &= ~(ICANON | ECHO);
Line:43 Str:    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
Line:44 Str:    
Line:45 Str:    ch = getchar();
Line:46 Str:    
Line:47 Str:    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
Line:48 Str:    return ch;
Line:49 Str:#endif
Line:50 Str:}
Line:51 Str:
Line:52 Str:// 处理特殊键的函数
Line:53 Str:int getchex() {
Line:54 Str:    char first_char = getch_simple();
Line:55 Str:    
Line:56 Str:    // 如果是 ESC，检查是否是方向键
Line:57 Str:    if (first_char == 27) {
Line:58 Str:        // 非阻塞地检查下一个字符
Line:59 Str:        // 使用简单的延迟，不要用 select
Line:60 Str:        #ifdef _WIN32
Line:61 Str:            // Windows: 方向键是 224 + 某个值
Line:62 Str:            if (_kbhit()) {
Line:63 Str:                char second_char = _getch();
Line:64 Str:                if (second_char == 224 && _kbhit()) {
Line:65 Str:                    char third_char = _getch();
Line:66 Str:                    switch (third_char) {
Line:67 Str:                        case 72: return KEY_UP;
Line:68 Str:                        case 80: return KEY_DOWN;
Line:69 Str:                        case 75: return KEY_LEFT;
Line:70 Str:                        case 77: return KEY_RIGHT;
Line:71 Str:                    }
Line:72 Str:                }
Line:73 Str:            }
Line:74 Str:        #else
Line:75 Str:            // Linux/macOS: 使用 usleep 等待并检查
Line:76 Str:            usleep(1000); // 10ms 延迟
Line:77 Str:            
Line:78 Str:            // 检查是否有字符可用（简化版本）
Line:79 Str:            struct termios oldt2, newt2;
Line:80 Str:            tcgetattr(STDIN_FILENO, &oldt2);
Line:81 Str:            newt2 = oldt2;
Line:82 Str:            newt2.c_lflag &= ~(ICANON | ECHO);
Line:83 Str:            newt2.c_cc[VMIN] = 0;  // 非阻塞读取
Line:84 Str:            newt2.c_cc[VTIME] = 0;
Line:85 Str:            tcsetattr(STDIN_FILENO, TCSANOW, &newt2);
Line:86 Str:            
Line:87 Str:            char second_char = getchar();
Line:88 Str:            if (second_char == '[') {
Line:89 Str:                char third_char = getchar();
Line:90 Str:                tcsetattr(STDIN_FILENO, TCSANOW, &oldt2);
Line:91 Str:                
Line:92 Str:                switch (third_char) {
Line:93 Str:                    case 'A': return KEY_UP;
Line:94 Str:                    case 'B': return KEY_DOWN;
Line:95 Str:                    case 'C': return KEY_RIGHT;
Line:96 Str:                    case 'D': return KEY_LEFT;
Line:97 Str:                }
Line:98 Str:            } else if (second_char != -1) {
Line:99 Str:                // 有其他字符，但不是方向键
Line:100 Str:                tcsetattr(STDIN_FILENO, TCSANOW, &oldt2);
Line:101 Str:            } else {
Line:102 Str:                tcsetattr(STDIN_FILENO, TCSANOW, &oldt2);
Line:103 Str:                return KEY_ESC;  // 单独的 ESC
Line:104 Str:            }
Line:105 Str:        #endif
Line:106 Str:        return KEY_ESC;  // 其他 ESC 序列也当作 ESC
Line:107 Str:    }
Line:108 Str:    
Line:109 Str:    return first_char;  // 返回普通字符
Line:110 Str:}
Line:111 Str:char getch() {
Line:112 Str:#ifdef _WIN32
Line:113 Str:    return _getch();
Line:114 Str:#else
Line:115 Str:    char ch;
Line:116 Str:    struct termios oldt, newt;
Line:117 Str:
Line:118 Str:    tcgetattr(STDIN_FILENO, &oldt);
Line:119 Str:    newt = oldt;
Line:120 Str:    newt.c_lflag &= ~(ICANON | ECHO);
Line:121 Str:    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
Line:122 Str:
Line:123 Str:    ch = getchar();
Line:124 Str:
Line:125 Str:    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
Line:126 Str:    return ch;
Line:127 Str:#endif
Line:128 Str:}
Line:129 Str:Buffer BUFFER=Buffer();
Line:130 Str:vector<Cursor> CURSORS;
Line:131 Str:int ROW_BEGIN=0,ROW_END=0,ROW_FACT=0,TUI_COL=10,TUI_ROW=10;
Line:132 Str:namespace Help {
Line:133 Str:	void GetHelp() {
Line:134 Str:		cout<<"=======欢迎使用 Qaaxaap-vim========"<<endl;
Line:135 Str:		cout<<"目前还在测试阶段，仅支持 qvim [file name] 以 qvim 打开文件"<<endl;
Line:136 Str:	}
Line:137 Str:}
Line:138 Str:std::pair<int,int> getTerminalSizeWithIoctl() {
Line:139 Str:    struct winsize w;
Line:140 Str:    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
Line:141 Str:
Line:142 Str://    std::cout << "终端大小 (ioctl):" << std::endl;
Line:143 Str://    std::cout << "行数: " << w.ws_row << std::endl;
Line:144 Str://    std::cout << "列数: " << w.ws_col << std::endl;
Line:145 Str://    std::cout << "水平像素: " << w.ws_xpixel << std::endl;
Line:146 Str://    std::cout << "垂直像素: " << w.ws_ypixel << std::endl;
Line:147 Str:	return {w.ws_col,w.ws_row};
Line:148 Str:}
Line:149 Str:int main(int argc,char* argv[]) {
Line:150 Str:	if(argc<2) {
Line:151 Str:		Help::GetHelp();
Line:152 Str:		return 0;
Line:153 Str:	}
Line:154 Str:	std::ofstream DeBugLogs("qvim.log",std::ios::trunc);
Line:155 Str:	cout<<"\x1b[?1049h"<<flush;
Line:156 Str:	tui::getTerminalSize();
Line:157 Str:	CURSORS.push_back(Cursor());
Line:158 Str:	for(auto &Cur:CURSORS)
Line:159 Str:		Cur.Move(0,0),Cur.Move_fact(0,0);
Line:160 Str:	std::string FileName=argv[1];
Line:161 Str:	std::ifstream inFile(FileName.c_str());
Line:162 Str:	if(!inFile) {
Line:163 Str:		std::cerr<<"文件错误或不存在，自动创建";
Line:164 Str:	}
Line:165 Str:	else {
Line:166 Str:		std::string Line;
Line:167 Str:		while(std::getline(inFile,Line)) {
Line:168 Str:			DeBugLogs<<"Line:"<<ROW_FACT<<" Str:"<<Line<<endl;
Line:169 Str:			std::string Ins="";
Line:170 Str:			for(char c:Line) {
Line:171 Str:				if(c==9) 
Line:172 Str:					for(int i=1;i<=4;i++) 
Line:173 Str:						Ins+=' ';
Line:174 Str:				else 
Line:175 Str:					Ins+=c;
Line:176 Str:			}
Line:177 Str:			ROW_FACT++;
Line:178 Str:			BUFFER.NewLine();
Line:179 Str:			BUFFER.Insert(ROW_FACT-1,0,Ins);
Line:180 Str:		}
Line:181 Str:		inFile.close();
Line:182 Str:	}
Line:183 Str:	if(BUFFER.size()==0)
Line:184 Str:		BUFFER.NewLine(),ROW_FACT++;
Line:185 Str://For Test
Line:186 Str:	cin>>std::noskipws;
Line:187 Str:	for(auto &Cur:CURSORS)
Line:188 Str:		Cur.Move(0,0),Cur.Move_fact(0,0);
Line:189 Str:	DeBugLogs<<"TUI size:"<<TUI_COL<<' '<<TUI_ROW<<endl;
Line:190 Str:	DeBugLogs<<"File rows:"<<ROW_FACT<<endl;
Line:191 Str:	tui::draw();
Line:192 Str:	while(1) {
Line:193 Str:		for(auto Cur:CURSORS) {
Line:194 Str:			DeBugLogs<<"Cursor Place:("<<Cur.Place_fact().first<<","<<Cur.Place_fact().second<<")"<<endl;
Line:195 Str:			DeBugLogs<<"Cursor Screen:("<<Cur.Place_screen().first<<","<<Cur.Place_screen().second<<")"<<endl;
Line:196 Str:		}
Line:197 Str:		int Chr;
Line:198 Str:		Chr=getchex();
Line:199 Str:		if(Chr==KEY_ESC) break;
Line:200 Str:		else if(Chr==9) {
Line:201 Str:			for(int i=1;i<=4;i++) {
Line:202 Str:				Edit::Insert(' ');
Line:203 Str:			}
Line:204 Str:		}
Line:205 Str:		else if(Chr==127) Edit::Delete();
Line:206 Str:		else if(Chr==KEY_UP) {
Line:207 Str:			for(auto &Cur:CURSORS) {
Line:208 Str:				if(Cur.Place_screen().second>0) 
Line:209 Str:					Cur.Up();
Line:210 Str:			}
Line:211 Str:		}
Line:212 Str:		else if(Chr==KEY_DOWN) {
Line:213 Str:			for(auto &Cur:CURSORS) {
Line:214 Str:				if(Cur.Place_screen().second<BUFFER.size()-1)
Line:215 Str:					Cur.Down();
Line:216 Str:			}
Line:217 Str:		}
Line:218 Str:		else if(Chr==KEY_LEFT) {
Line:219 Str:			for(auto &Cur:CURSORS) {
Line:220 Str:				if(Cur.Place_screen().first>0)
Line:221 Str:					Cur.Left();
Line:222 Str:			}
Line:223 Str:		}
Line:224 Str:		else if(Chr==KEY_RIGHT) {
Line:225 Str:			for(auto &Cur:CURSORS) {
Line:226 Str:				if(Cur.Place_screen().first<BUFFER.LineSize(Cur.Place_fact().second))
Line:227 Str:					Cur.Right();
Line:228 Str:			}
Line:229 Str:		}
Line:230 Str:		else if(Chr==4) {
Line:231 Str:			std::ofstream outFile(FileName.c_str(),std::ios::trunc);
Line:232 Str:			for(int i=0;i<BUFFER.size();i++) {
Line:233 Str:				//std::cerr<<BUFFER.ReadLine(i)<<endl;
Line:234 Str:				std::string Str=BUFFER.ReadLine(i);
Line:235 Str:				for(int i=0;i<Str.size();i++) 
Line:236 Str:					if(Str[i]!=0)
Line:237 Str:						outFile<<Str[i];
Line:238 Str:				outFile<<endl;
Line:239 Str:			}
Line:240 Str:			outFile.close();
Line:241 Str:			cout<<"File Write!"<<flush;
Line:242 Str:			usleep(300000);
Line:243 Str:		}
Line:244 Str:		else Edit::Insert((char)Chr);
Line:245 Str:		for(auto &Cur:CURSORS) {
Line:246 Str:			auto [x,y]=Cur.Place_screen();
Line:247 Str:			if(x>BUFFER.LineSize(y)) Cur.Move(BUFFER.LineSize(y),y);
Line:248 Str:		} 
Line:249 Str:		tui::draw();
Line:250 Str:		getTerminalSizeWithIoctl();
Line:251 Str:	}
Line:252 Str:	cout<<std::skipws;
Line:253 Str:	cout<<"\x1b[?1049l"<<flush;
Line:254 Str:	return 0;
Line:255 Str:}
Line:256 Str:
TUI size:168 46
File rows:257
Cursor Place:(0,0)
Cursor Screen:(0,0)
